<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sejong Bloom - 꽃 만들기</title>
    <link rel="stylesheet" href="styleflower.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
</head>

<body>
    <div class="step2box">
        <div class="img_container">
            <img src="/assets/phone10.jpg" alt="background">
        </div>
        <div class="step2-container">
            <div class="step2-header">
                <p class="step-subtitle" id="step2-sub-msg">로딩 중...</p>
                <h2 class="main-question">꽃은 어떻게 생겼을까?</h2>
                <p class="step-subtitle-guide"> 모양과 색을 골라 꽃을 만들어보자! </p>
            </div>

            <div class="controls-wrapper">
                <div class="palette-row">
                    <span class="control-label" style="font-family: 'UhBeeZIGLE';">모양 (Shape)</span>
                    <div id="flower-palette-container" class="scroll-palette">
                    </div>
                </div>

                <div class="palette-row">
                    <span class="control-label" style="font-family: 'UhBeeZIGLE';">색상 (Color)</span>
                    <div id="color-palette" class="scroll-palette">
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="c"></canvas>
                <div id="delete-zone" class="hidden">
                    <div class="trash-icon-bg"></div>
                </div>
            </div>

            <button class="finish-btn" onclick="saveAndMove()">완성하기</button>
        </div>
    </div>

    <script>
        // 1. 사용자 정보 가져오기
        const storedName = sessionStorage.getItem('userName') || "테스트";
        const storedDistrict = sessionStorage.getItem('userDistrict') || "dodam";

        const districtNames = {
            'eojindong': '어진동', 'dodam': '도담동', 'areum': '아름동',
            'hamildong': '한솔동', 'naseongdong': '나성동', 'bangok_jiphyeon': '반곡·집현동',
            'jochiwon': '조치원읍', 'jeonui_myeon': '전의면', 'yeonseomyeon': '연서면',
            'bugangmyeon': '부강면', 'geumnammyeon': '금남면', 'yeongimyeon': '연기면',
            'janggunmyeon': '장군면', 'yeondongmyeon': '연동면', 'otherarea': '기타 지역'
        };

        const districtKr = districtNames[storedDistrict] || "세종시";
        document.getElementById('step2-sub-msg').innerText = `${districtKr}에서 온 ${storedName}(이)의`;

        // 2. 색상 및 모양 데이터 정의
        const colorList = ['#FF9AA2', '#FFB7B2', '#FFDAC1', '#E2F0CB', '#B5EAD7', '#C7CEEA', '#FF6B6B', '#4DABF7', '#FFD43B', '#69DB7C', '#FCC2D7'];

        const allShapes = ['F1', 'F2', 'F3'];
        // 지역별 꽃 모양 프리셋 (기존 데이터 유지)
        const districtShapes = {
            'eojindong': ['F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7'],
            'dodam': ['F1', 'F2', 'F3', 'F8', 'F9', 'F10', 'F11'],
            'areum': ['F1', 'F2', 'F3', 'F12', 'F13', 'F14', 'F15'],
            'hamildong': ['F1', 'F2', 'F3', 'F16', 'F17', 'F18', 'F19'],
            'naseongdong': ['F1', 'F2', 'F3', 'F20', 'F21', 'F22', 'F23'],
            'bangok_jiphyeon': ['F1', 'F2', 'F3', 'F24', 'F25', 'F26', 'F27'],
            'jochiwon': ['F1', 'F2', 'F3', 'F28', 'F29', 'F30', 'F31'],
            'jeonui_myeon': ['F1', 'F2', 'F3', 'F15', 'F30', 'F32', 'F33'],
            'yeonseomyeon': ['F1', 'F2', 'F3', 'F6', 'F8', 'F13', 'F34'],
            'bugangmyeon': ['F1', 'F2', 'F3', 'F35', 'F36', 'F37', 'F38'],
            'geumnammyeon': ['F1', 'F2', 'F3', 'F14', 'F26', 'F36', 'F39'],
            'yeongimyeon': ['F1', 'F2', 'F3', 'F32', 'F40', 'F41', 'F42'],
            'janggunmyeon': ['F1', 'F2', 'F3', 'F13', 'F43', 'F44', 'F45'],
            'yeondongmyeon': ['F1', 'F2', 'F3', 'F22', 'F36', 'F44', 'F46'],
            'otherarea': ['F1', 'F2', 'F3', 'F11', 'F35', 'F47', 'F48']
        };

        const myShapes = districtShapes[storedDistrict] || allShapes;
        let currentSelectedColor = colorList[0];

        // 3. 캔버스 초기화
        const canvas = new fabric.Canvas('c', {
            preserveObjectStacking: true
        });
        canvas.backgroundColor = 'transparent';

        window.onload = function () {
            resizeCanvas();
            initColorPalette();
            generatePalette(myShapes);
        };

        window.addEventListener('resize', resizeCanvas);

        function resizeCanvas() {
            const wrapper = document.querySelector('.canvas-wrapper');
            if (wrapper) {
                const size = wrapper.clientWidth;
                canvas.setWidth(size);
                canvas.setHeight(size);
                canvas.renderAll();
            }
        }

        // 4. 팔레트 생성 로직
        function initColorPalette() {
            const container = document.getElementById('color-palette');
            container.innerHTML = '';
            colorList.forEach((color, idx) => {
                const btn = document.createElement('div');
                btn.className = 'color-btn';
                if (idx === 0) btn.classList.add('active');
                btn.style.backgroundColor = color;
                btn.onclick = () => selectColor(btn, color);
                container.appendChild(btn);
            });
        }

        function selectColor(btn, color) {
            currentSelectedColor = color;
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            const activeObj = canvas.getActiveObject();
            if (activeObj) {
                applyColor(activeObj, color);
                canvas.renderAll();
            }
            updateShapeButtons(color);
        }

        async function generatePalette(shapes) {
            const container = document.getElementById('flower-palette-container');
            container.innerHTML = '';

            for (let shape of shapes) {
                const filePath = `assets/${shape}.svg`; // 경로 주의
                try {
                    const res = await fetch(filePath);
                    if (!res.ok) throw new Error('SVG Load Fail');
                    let svgText = await res.text();

                    const btn = document.createElement('div');
                    btn.className = 'shape-btn';
                    btn.dataset.svg = svgText;
                    btn.dataset.type = shape;
                    btn.innerHTML = svgText.replace(/fill="[^"]*"/g, `fill="${currentSelectedColor}"`);

                    btn.onclick = () => addShapeToCanvas(shape, currentSelectedColor);
                    container.appendChild(btn);
                } catch (e) {
                    console.warn(`[Shape Error] ${shape}:`, e);
                }
            }
        }

        function updateShapeButtons(color) {
            document.querySelectorAll('.shape-btn').forEach(btn => {
                const svg = btn.dataset.svg;
                if (svg) btn.innerHTML = svg.replace(/fill="[^"]*"/g, `fill="${color}"`);
            });
        }

        // 5. 캔버스 조작 로직 (추가, 색상변경, 삭제)
        function addShapeToCanvas(type, color) {
            fabric.loadSVGFromURL(`assets/${type}.svg`, (objects, options) => {
                const obj = fabric.util.groupSVGElements(objects, options);
                applyColor(obj, color);

                const canvasWidth = canvas.getWidth();
                // 캔버스 크기의 30% 정도로 로드
                const initialScale = (canvasWidth * 0.3) / Math.max(obj.width, obj.height);
                const center = canvas.getCenter();

                obj.set({
                    left: center.left, top: center.top,
                    originX: 'center', originY: 'center',
                    scaleX: 0, scaleY: 0,
                    cornerColor: 'rgba(0,0,0,0.5)', transparentCorners: false
                });
                obj.userColor = color;
                obj.type = type;

                canvas.add(obj);
                canvas.setActiveObject(obj);

                // 팝업 애니메이션
                obj.animate('scaleX', initialScale, { duration: 400, onChange: canvas.renderAll.bind(canvas), easing: fabric.util.ease.easeOutBack });
                obj.animate('scaleY', initialScale, { duration: 400, easing: fabric.util.ease.easeOutBack });
            });
        }

        function applyColor(obj, color) {
            obj.userColor = color;
            if (obj.isType('group')) {
                obj.getObjects().forEach(o => { if (o.fill !== 'none') o.set('fill', color); });
            } else { obj.set('fill', color); }
        }

        // 삭제 영역 로직
        const deleteZone = document.getElementById('delete-zone');

        canvas.on('object:moving', (e) => {
            deleteZone.classList.remove('hidden');
            if (e.target.top > canvas.getHeight() * 0.8) {
                deleteZone.classList.add('delete-active');
                e.target.opacity = 0.5;
            } else {
                deleteZone.classList.remove('delete-active');
                e.target.opacity = 1;
            }
        });

        canvas.on('mouse:up', () => {
            const obj = canvas.getActiveObject();
            deleteZone.classList.add('hidden');
            deleteZone.classList.remove('delete-active');

            if (obj && obj.top > canvas.getHeight() * 0.8) {
                canvas.remove(obj);
                canvas.discardActiveObject();
                canvas.renderAll();
            }
        });

        /* ============================================================
           [핵심 수정] 저장 후 페이지 8로 이동하는 함수
           1. 모양 데이터 JSON 생성 (나중에 서버 전송용)
           2. 캔버스 이미지(PNG) 생성 (다음 페이지 시각화용)
           3. sessionStorage에 저장 후 이동
        ============================================================ */
        function saveAndMove() {
            // 1. 선택 상자가 저장되는 것 방지
            canvas.discardActiveObject();
            canvas.renderAll();

            const objects = canvas.getObjects();
            if (objects.length === 0) { alert('꽃을 만들어주세요!'); return; }

            // --- [STEP 1] 꽃 뭉치의 전체 영역(Bounding Box) 계산 ---
            // 꽃들이 뭉쳐있는 곳의 정중앙(Center)을 찾습니다.
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            objects.forEach(obj => {
                const bound = obj.getBoundingRect(); // 회전된 상태까지 고려한 영역
                if (bound.left < minX) minX = bound.left;
                if (bound.top < minY) minY = bound.top;
                if (bound.left + bound.width > maxX) maxX = bound.left + bound.width;
                if (bound.top + bound.height > maxY) maxY = bound.top + bound.height;
            });

            const groupCenterX = (minX + maxX) / 2;
            const groupCenterY = (minY + maxY) / 2;

            // --- [STEP 2] 유니티 전송용 데이터 변환 (상대 좌표) ---
            // 캔버스 크기에 따른 비율 보정 (웹 500px -> 유니티 5 Unit 정도 비율로 가정)
            const SCALE_FACTOR = 0.01;

            const unityDataList = objects.map((o, index) => {
                // 중심점(groupCenter)을 기준으로 얼마나 떨어져 있는지 계산
                const relativeX = (o.left - groupCenterX) * SCALE_FACTOR;
                const relativeY = (o.top - groupCenterY) * SCALE_FACTOR * -1; // ★ Y축 반전 (중요)

                return {
                    prefabName: o.type,       // 유니티 프리팹 이름 (예: "F1")
                    color: o.userColor,       // 색상

                    // 위치 (꽃 뭉치 중앙 기준)
                    posX: parseFloat(relativeX.toFixed(4)),
                    posY: parseFloat(relativeY.toFixed(4)),

                    // 크기
                    scaleX: parseFloat((o.scaleX * SCALE_FACTOR * 100).toFixed(4)), // 보정값
                    scaleY: parseFloat((o.scaleY * SCALE_FACTOR * 100).toFixed(4)),

                    // 회전 (웹은 시계방향, 유니티는 반시계방향 -> -부호 붙임)
                    rotation: -o.angle,

                    // 순서 (나중에 그린게 위에 올라옴)
                    sortOrder: index
                };
            });

            // --- [STEP 3] 웹 시각화용 이미지 생성 (Page 8 표시용) ---
            const flowerImageUrl = canvas.toDataURL({
                format: 'png',
                quality: 1.0,
                multiplier: 2
            });

            // --- [STEP 4] 저장 ---
            const data = {
                userName: storedName,
                location: storedDistrict,
                unityData: unityDataList, // 유니티가 쓸 좌표 데이터
                previewImage: flowerImageUrl // 웹에서 보여줄 이미지
            };

            sessionStorage.setItem('flowerData', JSON.stringify(data));
            console.log("유니티 전송용 데이터 생성 완료:", data);

            alert("꽃 디자인이 저장되었습니다! \n물을 주러 가볼까요?");
            window.location.href = '/page8.html'; // 경로 확인 필요
        }
    </script>
</body>

</html>