<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sejong Bloom - The Garden</title>
    <style>
        /* í°íŠ¸ ì„¤ì • */
        @font-face {
            font-family: 'UhBeeZIGLE';
            src: url('https://gcore.jsdelivr.net/gh/projectnoonnu/noonfonts_five@.2.0/UhBeeZIGLE.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }

        @font-face {
            font-family: 'OngleipParkDahyeon';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2411-3@1.0/Ownglyph_ParkDaHyun.woff2') format('woff2');
            font-weight: normal;
            font-display: swap;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
        }

        /* 3D ë¼ë²¨ ìŠ¤íƒ€ì¼ */
        .flower-label {
            margin-top: -45px;
            color: white;
            font-family: 'OngleipParkDahyeon';
            font-size: 14px;
            font-weight: 300;
            padding: 5px;
            pointer-events: none;
            opacity: 1;
            /* ê¸°ë³¸ ë¶ˆíˆ¬ëª…ë„ */
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
            /* ê°€ë…ì„±ì„ ìœ„í•´ ê·¸ë¦¼ì ì¶”ê°€ ì¶”ì²œ */
        }

        #guide {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 18px;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* --- ğŸŒ¼ UI ì»¨í…Œì´ë„ˆ (ë°˜ì‘í˜• % ì ìš©) --- */
        #ui-container {
            position: absolute;
            top: 5%;
            right: 1%;
            width: 22%;
            height: 90%;
            min-width: 260px;
            max-width: 500px;
            max-height: 98vh;
            background-image: url('/public/assets/final_list.png');
            background-repeat: no-repeat;
            background-size: 100% 100%;
            background-color: transparent;
            border: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
            pointer-events: none;
        }

        #ui-container h3 {
            display: none;
        }

        /* --- ğŸ“‹ ë¦¬ìŠ¤íŠ¸ ì˜ì—­ --- */
        #flower-list {
            margin-top: 30%;
            margin-bottom: 10%;

            /* ğŸ‘‡ ë„ˆë¹„ë¥¼ 70%ì—ì„œ 60%ë¡œ ì¤„ì—¬ì„œ ì—¬ë°±ì„ í™•ë³´ */
            width: 68%;
            height: 86%;
            overflow-y: auto;
            pointer-events: auto;
            padding-right: 2px;
            position: relative;

            /* ğŸ‘‡ ë§ˆì´ë„ˆìŠ¤(-) ê°’ì„ ë„£ì–´ ì™¼ìª½ìœ¼ë¡œ ë‹¹ê¸°ê¸° */
            transform: translateX(30px);
        }

        /* --- ğŸŒ¼ ë¦¬ìŠ¤íŠ¸ ì•„ì´í…œ (ë²„íŠ¼) --- */
        .flower-item {
            display: block;
            width: 86%;
            box-sizing: border-box;
            padding: 10px 0;
            margin-bottom: 1.5vh;
            background: white;
            border: 1px solid #ddd;
            border-radius: 12px;
            font-family: 'Noto Sans KR', sans-serif;
            font-size: clamp(12px, 1.5vw, 15px);
            color: #555;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .flower-item:hover {
            background: #fdfdfd;
            border-color: #87CEEB;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            color: #333;
        }

        .flower-icon {
            display: none;
        }

        /* ìŠ¤í¬ë¡¤ë°” */
        #flower-list::-webkit-scrollbar {
            width: 6px;
        }

        #flower-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        #flower-list::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }

        #flower-list::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        /* --- ğŸ“± ëª¨ë°”ì¼ ì „ìš© ìŠ¤íƒ€ì¼ --- */
        #mobile-random-btn {
            display: none;
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 30px;
            color: white;
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            z-index: 25;
            transition: transform 0.2s, background 0.2s;
            white-space: nowrap;
        }

        #mobile-random-btn:active {
            transform: translateX(-50%) scale(0.95);
            background: rgba(255, 255, 255, 0.4);
        }

        @media (max-width: 768px) {
            #ui-container {
                display: none !important;
            }

            #mobile-random-btn {
                display: flex;
                align-items: center;
                gap: 8px;
            }
        }
    </style>

    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body>

    <div id="guide">ì´ê²Œ ìš°ë¦¬ì˜ ì •ì›ì´ì•¼!</div>

    <div id="ui-container">
        <div id="flower-list">
        </div>
    </div>

    <button id="mobile-random-btn">
        ë‹¤ë¥¸ ê½ƒë“¤ë„ ë‘˜ëŸ¬ë³¼ë˜?
    </button>

    <script type="x-shader/x-vertex" id="skyVertexShader">
        varying vec2 vUv; varying vec3 vWorldPosition; void main() { vUv = uv; vec4 worldPosition = modelMatrix * vec4(position, 1.0); vWorldPosition = worldPosition.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>
    <script type="x-shader/x-fragment" id="skyFragmentShader">
        uniform vec3 uColorSkyTop; uniform vec3 uColorSkyBottom; uniform vec3 uColorCloud; uniform float uTime; varying vec2 vUv; varying vec3 vWorldPosition;
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); } vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0)); float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ * ns.x + ns.yyyy; vec4 y = y_ * ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw); vec4 s0 = floor(b0) * 2.0 + 1.0; vec4 s1 = floor(b1) * 2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw * sh.xzyw; vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww; vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); m = m * m; return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))); }
        void main() { float horizon = normalize(vWorldPosition).y; vec3 skyColor = mix(uColorSkyBottom, uColorSkyTop, max(horizon, 0.0)); float cloudNoise = snoise(vWorldPosition * 0.0008 + vec3(uTime * 0.015, 0.0, uTime * 0.005)); cloudNoise += snoise(vWorldPosition * 0.002 + vec3(uTime * 0.03)) * 0.4; float cloudIntensity = smoothstep(0.45, 0.75, cloudNoise); cloudIntensity *= smoothstep(0.0, 0.15, horizon); vec3 finalColor = mix(skyColor, uColorCloud, cloudIntensity); gl_FragColor = vec4(finalColor, 1.0); }
    </script>
    <script type="x-shader/x-vertex" id="grassVertexShader">
        varying vec2 vUv; varying float vHeight; uniform float uTime; void main() { vUv = uv; vec4 worldPosition = instanceMatrix * vec4(position, 1.0); vHeight = position.y; float wind = sin(uTime * 0.8 + worldPosition.x * 0.2 + worldPosition.z * 0.2) * 0.08; wind += cos(uTime * 2.0 + worldPosition.x * 0.1) * 0.04; float bend = smoothstep(0.0, 1.0, vHeight); vec3 pos = position; pos.x += wind * bend * 2.0; pos.z += wind * bend * 1.0; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.0); }
    </script>
    <script type="x-shader/x-fragment" id="grassFragmentShader">
        varying float vHeight; uniform vec3 uColorBottom; uniform vec3 uColorTop; void main() { float smoothHeight = pow(vHeight, 0.7); vec3 baseColor = mix(uColorBottom, uColorTop, smoothHeight); float softGlow = smoothstep(0.5, 1.0, vHeight) * 0.2; vec3 finalColor = baseColor + softGlow + vec3(0.05); gl_FragColor = vec4(finalColor, 1.0); }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        const myName = sessionStorage.getItem('userName');
        // ğŸ”´ ì„œë²„ ì£¼ì†Œ (AWS IP)
        const SERVER_URL = "http://15.134.86.182:3000";
        const FLOWER_GLOBAL_SCALE = 1;  // ê½ƒ ì „ì²´ í¬ê¸°
        const PART_SIZE_SCALE = 400.0;  // íŒŒì¸  í¬ê¸°
        const PART_SPACING = 10.0;  // íŒŒì¸  ê°„ê²©
        const FLOWER_BASE_HEIGHT = 0.001;  // ë•…ì—ì„œ ë„ìš°ëŠ” ê¸°ë³¸ ë†’ì´

        const CONFIG = {
            flowerScale: 1.5,
            worldSize: 300, grassCount: 160000, treeCount: 60, rockCount: 60
        };

        let seedValue = 123456;
        function seededRandom() {
            var t = seedValue += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        const loader = new GLTFLoader();
        const prefabCache = {};
        const flowers = [];
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();

        // 1. ì”¬ & ë Œë”ëŸ¬ ì„¤ì •
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 30, 90);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.maxDistance = 150; controls.minDistance = 5;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.target.set(0, 5, 0); controls.enableDamping = true;

        const sunLight = new THREE.DirectionalLight(0xfff0dd, 2.0);
        sunLight.position.set(80, 100, 60);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(2048, 2048);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0xcceeff, 0.7));

        // 2. í™˜ê²½ ìƒì„±
        const skyUniforms = { uTime: { value: 0 }, uColorSkyTop: { value: new THREE.Color(0x4CA1D3) }, uColorSkyBottom: { value: new THREE.Color(0xAEEEEE) }, uColorCloud: { value: new THREE.Color(0xFFFFFF) } };
        const skyMat = new THREE.ShaderMaterial({ vertexShader: document.getElementById('skyVertexShader').textContent, fragmentShader: document.getElementById('skyFragmentShader').textContent, uniforms: skyUniforms, side: THREE.BackSide });
        scene.add(new THREE.Mesh(new THREE.SphereGeometry(4000, 32, 32), skyMat));
        scene.fog = new THREE.Fog(0xAEEEEE, 60, 200);

        function getTerrainHeight(x, z) { const y1 = Math.sin(x * 0.02) * 6.0; const y2 = Math.cos(z * 0.025) * 5.0; const y3 = Math.sin(x * 0.05 + z * 0.05) * 2.0; return (y1 + y2 + y3) - 3; }
        function createTerrain() { const geo = new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize, 64, 64); geo.rotateX(-Math.PI / 2); const pos = geo.attributes.position; for (let i = 0; i < pos.count; i++) { pos.setY(i, getTerrainHeight(pos.getX(i), pos.getZ(i))); } geo.computeVertexNormals(); const mat = new THREE.MeshStandardMaterial({ color: 0x7a9c6b }); const terrain = new THREE.Mesh(geo, mat); terrain.receiveShadow = true; scene.add(terrain); }

        const grassUniforms = { uTime: { value: 0 }, uColorBottom: { value: new THREE.Color(0x6a9e7a) }, uColorTop: { value: new THREE.Color(0xc3e8a8) } };
        function createGrass() { const grassGeo = new THREE.ConeGeometry(0.03, 1.0, 3, 1); grassGeo.translate(0, 0.5, 0); const grassMat = new THREE.ShaderMaterial({ vertexShader: document.getElementById('grassVertexShader').textContent, fragmentShader: document.getElementById('grassFragmentShader').textContent, uniforms: grassUniforms, side: THREE.DoubleSide }); const mesh = new THREE.InstancedMesh(grassGeo, grassMat, CONFIG.grassCount); for (let i = 0; i < CONFIG.grassCount; i++) { const x = (seededRandom() - 0.5) * CONFIG.worldSize; const z = (seededRandom() - 0.5) * CONFIG.worldSize; const y = getTerrainHeight(x, z); dummy.position.set(x, y, z); const scale = 0.6 + seededRandom() * 0.6; dummy.scale.set(scale, scale * 0.8, scale); dummy.rotation.y = seededRandom() * Math.PI; dummy.rotation.x = (seededRandom() - 0.5) * 0.3; dummy.rotation.z = (seededRandom() - 0.5) * 0.3; dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); } mesh.receiveShadow = true; scene.add(mesh); }

        function createTrees() { const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 5); trunkGeo.translate(0, 0.75, 0); const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5D4037, flatShading: true }); const leafGeo = new THREE.DodecahedronGeometry(2.2, 0); leafGeo.translate(0, 3.0, 0); const leafMat = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true }); const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, CONFIG.treeCount); const leafMesh = new THREE.InstancedMesh(leafGeo, leafMat, CONFIG.treeCount); const leafColors = [0xFF7F50, 0xFFA07A, 0xFFD700, 0xE9967A]; for (let i = 0; i < CONFIG.treeCount; i++) { let x, z, dist; do { x = (seededRandom() - 0.5) * CONFIG.worldSize; z = (seededRandom() - 0.5) * CONFIG.worldSize; dist = Math.sqrt(x * x + z * z); } while (dist < 35); const y = getTerrainHeight(x, z); dummy.position.set(x, y, z); const scale = 0.8 + seededRandom() * 0.8; dummy.scale.set(scale, scale, scale); dummy.rotation.y = seededRandom() * Math.PI; dummy.updateMatrix(); trunkMesh.setMatrixAt(i, dummy.matrix); leafMesh.setMatrixAt(i, dummy.matrix); color.setHex(leafColors[Math.floor(seededRandom() * leafColors.length)]); leafMesh.setColorAt(i, color); } scene.add(trunkMesh); scene.add(leafMesh); }

        function createRocks() { const geo = new THREE.DodecahedronGeometry(1, 0); const mat = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, flatShading: true }); const mesh = new THREE.InstancedMesh(geo, mat, CONFIG.rockCount); for (let i = 0; i < CONFIG.rockCount; i++) { const x = (seededRandom() - 0.5) * CONFIG.worldSize; const z = (seededRandom() - 0.5) * CONFIG.worldSize; const y = getTerrainHeight(x, z); dummy.position.set(x, y + 0.3, z); dummy.scale.set(1 + seededRandom(), 0.6 + seededRandom(), 1 + seededRandom()); dummy.rotation.set(seededRandom() * 3, seededRandom() * 3, seededRandom() * 3); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); } scene.add(mesh); }

        function createCliffs() { const columnGeo = new THREE.CylinderGeometry(3.5, 3.5, 60, 6); columnGeo.translate(0, 30, 0); const columnMat = new THREE.MeshStandardMaterial({ color: 0x3E424B, flatShading: true, roughness: 0.9 }); const cliffClusters = 8; const columnsPerCluster = 50; const totalColumns = cliffClusters * columnsPerCluster; const cliffMesh = new THREE.InstancedMesh(columnGeo, columnMat, totalColumns); let idx = 0; for (let i = 0; i < cliffClusters; i++) { const angle = (i / cliffClusters) * Math.PI * 2 + seededRandom() * 0.5; const dist = CONFIG.worldSize / 2 + 10 + seededRandom() * 20; const centerX = Math.cos(angle) * dist; const centerZ = Math.sin(angle) * dist; for (let j = 0; j < columnsPerCluster; j++) { const offsetX = (seededRandom() - 0.5) * 35; const offsetZ = (seededRandom() - 0.5) * 35; const heightScale = 0.8 + seededRandom() * 1.4; const groundY = getTerrainHeight(centerX + offsetX, centerZ + offsetZ); dummy.position.set(centerX + offsetX, groundY - 15, centerZ + offsetZ); dummy.scale.set(1, heightScale, 1); dummy.rotation.set(0, seededRandom() * Math.PI, 0); dummy.updateMatrix(); cliffMesh.setMatrixAt(idx++, dummy.matrix); } } scene.add(cliffMesh); }

        // --- 3. ğŸŒ¸ ëª¨ë¸ ë¡œë”© ---
        async function getModel(prefabName) {
            if (prefabCache[prefabName]) return prefabCache[prefabName];
            const path = `/assets/${prefabName}.glb`;
            try {
                const gltf = await loader.loadAsync(path);
                prefabCache[prefabName] = gltf.scene;
                return gltf.scene;
            } catch (e) { return null; }
        }

        // --- 4. ğŸŒ¸ ê½ƒ ìƒì„± (ë¹„ìœ¨ ì™„ë²½ ìœ ì§€ & ì• ë‹ˆë©”ì´ì…˜) ---
        async function createFlower(data, isFromSocket = false) {
            try {
                /* ===============================
                   ğŸŒ± Root / Visual ë¶„ë¦¬
                =============================== */
                const flowerRoot = new THREE.Group();    // ìœ„ì¹˜ìš© (ë•… ê¸°ì¤€)
                const flowerVisual = new THREE.Group();  // ìŠ¤ì¼€ì¼ / íšŒì „ìš©

                flowerRoot.userData = {
                    isFlower: true,
                    isGrowing: true,
                    growProgress: 0,
                    swayOffset: Math.random() * 100,
                    userName: data.userName,
                    visual: flowerVisual
                };

                /* ===============================
                   ğŸ“ ìœ„ì¹˜ (ë•… ê¸°ì¤€)
                =============================== */
                const x = Number(data.gardenX) || 0;
                const z = Number(data.gardenZ) || 0;
                const groundY = getTerrainHeight(x, z);

                flowerRoot.position.set(x, groundY, z);

                /* ===============================
                   ğŸŒ¸ íŒŒì¸  ìƒì„±
                =============================== */
                const parts = Array.isArray(data.unityData) ? data.unityData : [];

                for (const partData of parts) {
                    const container = new THREE.Group();

                    // 2D â†’ 3D ìœ„ì¹˜
                    container.position.set(
                        partData.posX * PART_SPACING,
                        partData.posY * PART_SPACING,
                        partData.sortOrder * 0.1
                    );

                    // íšŒì „
                    container.rotation.z =
                        THREE.MathUtils.degToRad(-partData.rotation);

                    // í¬ê¸°
                    const s = partData.scaleX * PART_SIZE_SCALE;
                    container.scale.set(s, s, s);

                    // ìŠ¬ë¼ì´ë”ìš© ì›ë³¸ê°’ ì €ì¥
                    container.userData.originPos = {
                        x: partData.posX,
                        y: partData.posY
                    };
                    container.userData.originScale = partData.scaleX;

                    // ëª¨ë¸ ë¡œë“œ
                    let mesh;
                    const template = await getModel(partData.prefabName);
                    if (template) {
                        mesh = template.clone();
                    } else {
                        mesh = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 0.2),
                            new THREE.MeshBasicMaterial({ color: 0xff0000 })
                        );
                    }

                    // ë¨¸í‹°ë¦¬ì–¼
                    const colorHex = partData.color.startsWith('#')
                        ? partData.color
                        : '#' + partData.color;

                    const mat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(colorHex),
                        roughness: 0.6,
                        metalness: 0.1,
                        side: THREE.DoubleSide
                    });

                    mesh.traverse(c => {
                        if (c.isMesh) {
                            c.material = mat;
                            c.castShadow = true;
                            c.receiveShadow = true;
                        }
                    });

                    // ëª¨ë¸ ì„¸ìš°ê¸°
                    mesh.rotation.x = -Math.PI / 2;

                    container.add(mesh);
                    flowerVisual.add(container);
                }

                /* ===============================
                   ğŸŒ± pivotì„ "ë§¨ ì•„ë˜"ë¡œ ì •í™•íˆ ì´ë™
                =============================== */
                const box = new THREE.Box3().setFromObject(flowerVisual);

                // ğŸ”‘ í•µì‹¬: ìµœí•˜ë‹¨ì„ y = 0ìœ¼ë¡œ
                flowerVisual.position.y = -box.min.y;

                /* ===============================
                   ğŸ· ì´ë¦„í‘œ (ì§€ì—­ í•œê¸€í™” + ì¤„ë°”ê¿ˆ + íˆ¬ëª…ë„ ì„¤ì •)
                =============================== */
                const nameDiv = document.createElement('div');
                nameDiv.className = 'flower-label';

                // âœ¨ ë‘ ì¤„ì´ë‹ˆê¹Œ ê°€ìš´ë° ì •ë ¬
                nameDiv.style.textAlign = 'center';

                // 1. ì§€ì—­ ë§¤í•‘ ë¦¬ìŠ¤íŠ¸
                const districtNames = {
                    'eojindong': 'ì–´ì§„ë™', 'dodam': 'ë„ë‹´ë™', 'areum': 'ì•„ë¦„ë™',
                    'hamildong': 'í•œì†”ë™', 'naseongdong': 'ë‚˜ì„±ë™', 'bangok_jiphyeon': 'ë°˜ê³¡Â·ì§‘í˜„ë™',
                    'jochiwon': 'ì¡°ì¹˜ì›ì', 'jeonui_myeon': 'ì „ì˜ë©´', 'yeonseomyeon': 'ì—°ì„œë©´',
                    'bugangmyeon': 'ë¶€ê°•ë©´', 'geumnammyeon': 'ê¸ˆë‚¨ë©´', 'yeongimyeon': 'ì—°ê¸°ë©´',
                    'janggunmyeon': 'ì¥êµ°ë©´', 'yeondongmyeon': 'ì—°ë™ë©´', 'otherarea': 'ê¸°íƒ€ ì§€ì—­'
                };

                // 2. í…ìŠ¤íŠ¸ ë‚´ìš© ë§Œë“¤ê¸°
                let locationPart = "";
                if (data.location) {
                    const koreanName = districtNames[data.location] || data.location;
                    locationPart = `${koreanName}ì—ì„œ ì˜¨`;
                }

                // 3. HTML ì ìš© (<br> ì¤„ë°”ê¿ˆ)
                if (locationPart) {
                    nameDiv.innerHTML = `${locationPart}<br>${data.userName || 'ì†ë‹˜'}ì˜ ê½ƒ`;
                } else {
                    nameDiv.textContent = `${data.userName || 'ì†ë‹˜'}ì˜ ê½ƒ`;
                }

                // 4. ë¼ë²¨ ê°ì²´ ìƒì„± ë° ìœ„ì¹˜ ì¡ê¸°
                const label = new CSS2DObject(nameDiv);

                // ë°•ìŠ¤ ë†’ì´ë§Œí¼ ìœ„ë¡œ ë„ìš°ê¸° (+5ëŠ” ì—¬ìœ  ê°„ê²©)
                label.position.set(0, box.max.y - box.min.y + 5, 0);

                flowerVisual.add(label);

                // âœ¨ [í•µì‹¬] ë‚˜ì¤‘ì— animate í•¨ìˆ˜ì—ì„œ íˆ¬ëª…ë„ë¥¼ ì¡°ì ˆí•˜ê¸° ìœ„í•´ ì €ì¥í•´ë‘¡ë‹ˆë‹¤.
                flowerRoot.userData.labelObject = label;

                /* ===============================
                   ğŸŒ± ì”¬ì— ì¶”ê°€
                =============================== */
                flowerRoot.add(flowerVisual);

                // ì„±ì¥ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ê°’
                flowerVisual.scale.set(0, 0, 0);

                scene.add(flowerRoot);
                flowers.push(flowerRoot);
                addFlowerToList(data.userName || 'ì†ë‹˜', flowerRoot);

                if (isFromSocket || data.userName === myName) {
                    focusAndExplore(flowerRoot);
                }

            } catch (err) {
                console.error("ğŸŒ¸ createFlower ì—ëŸ¬:", err);
            }
        }




        // --- 5. ğŸ“· ì¹´ë©”ë¼ ë¡œì§ (í”¼ì–´ë‚œ í›„ ììœ  íƒìƒ‰) ---

        let isCameraLocked = false;    // ì¹´ë©”ë¼ê°€ ê°•ì œë¡œ ì›€ì§ì´ëŠ” ì¤‘ì¸ì§€
        let lockTimer = null;          // íƒ€ì´ë¨¸

        function focusAndExplore(flowerGroup) {
            // 1. ì¹´ë©”ë¼ ê°•ì œ ì´ë™ ì‹œì‘
            isCameraLocked = true;

            const fPos = flowerGroup.position.clone();

            // ëª©í‘œ: ê½ƒì„ ë°”ë¼ë´„ (ì•½ê°„ ìœ„)
            targetControlsTarget = fPos.clone().add(new THREE.Vector3(0, 5, 0));

            // ìœ„ì¹˜: ê½ƒ ì•ìª½ ìœ„
            // í˜„ì¬ ì¹´ë©”ë¼ ê°ë„ë¥¼ ìœ ì§€í•˜ë©´ì„œ ê±°ë¦¬ ì¢í˜
            const direction = camera.position.clone().sub(controls.target).normalize();
            targetCameraPos = fPos.clone().add(direction.multiplyScalar(20)).add(new THREE.Vector3(0, 5, 0));

            // 2. íƒ€ì´ë¨¸ ì„¤ì •: 3.5ì´ˆ í›„ì— ì¹´ë©”ë¼ ë½ í•´ì œ (ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚  ë•Œì¯¤)
            if (lockTimer) clearTimeout(lockTimer);

            lockTimer = setTimeout(() => {
                isCameraLocked = false;       // ë½ í•´ì œ
                targetCameraPos = null;       // ëª©í‘œ ìœ„ì¹˜ ì´ˆê¸°í™”
                targetControlsTarget = null;  // ëª©í‘œ íƒ€ê²Ÿ ì´ˆê¸°í™”
                console.log("ğŸ”“ ììœ  íƒìƒ‰ ëª¨ë“œ ì „í™˜!");
            }, 3500); // 3.5ì´ˆ í›„ í•´ì œ
        }

        // UI ë¦¬ìŠ¤íŠ¸ì—ì„œ í´ë¦­í–ˆì„ ë•Œë„ ë™ì¼í•˜ê²Œ ì‘ë™
        function focusOnFlower(flowerGroup) {
            focusAndExplore(flowerGroup);
        }

        function addFlowerToList(name, flowerGroup) {
            const listContainer = document.getElementById('flower-list');
            const item = document.createElement('div');
            item.className = 'flower-item';

            // userDataì—ì„œ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì‹œë„
            const userData = flowerGroup.userData;
            const userName = userData.userName || name;

            // ë¦¬ìŠ¤íŠ¸ì—ëŠ” ê°„ë‹¨í•˜ê²Œ "OOOì˜ ê½ƒ"ë§Œ ì¶œë ¥
            item.innerText = userName + "ì˜ ê½ƒ";

            item.onclick = (e) => {
                e.stopPropagation();
                focusOnFlower(flowerGroup);
            };

            listContainer.prepend(item);
        }

        async function loadInitialFlowers() {
            try {
                const response = await fetch(`${SERVER_URL}/all-flowers`);
                const allFlowers = await response.json();
                for (const flowerData of allFlowers) await createFlower(flowerData, false);
            } catch (e) { console.error(e); }
        }

        const socket = io(SERVER_URL);
        socket.on("to_unity", (data) => createFlower(data, true));

        // ì¸í„°ë™ì…˜
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let targetCameraPos = null; let targetControlsTarget = null;

        window.addEventListener('pointerdown', (event) => {
            if (event.target.closest('#ui-container')) return;
            // ì¹´ë©”ë¼ê°€ ë½ ê±¸ë ¤ìˆìœ¼ë©´ í´ë¦­ ë¬´ì‹œ (ê½ƒ í”¼ëŠ” ì¤‘ì—ëŠ” ë°©í•´ X)
            if (isCameraLocked) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(flowers, true);
            if (intersects.length > 0) {
                let targetGroup = intersects[0].object;
                while (targetGroup.parent && targetGroup.parent.type !== 'Scene') targetGroup = targetGroup.parent;
                if (targetGroup && targetGroup.userData.isFlower) { focusOnFlower(targetGroup); }
            }
        });

        const clock = new THREE.Clock();

        // ğŸŸ¢ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ (ì¤‘ë³µ ì œê±° ë° í†µí•©ë¨)
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();

            grassUniforms.uTime.value = time;
            skyUniforms.uTime.value = time;

            // ğŸ“· ì¹´ë©”ë¼ ê°•ì œ ì´ë™ (ë½ ê±¸ë ¤ìˆì„ ë•Œë§Œ)
            if (isCameraLocked && targetCameraPos && targetControlsTarget) {
                camera.position.lerp(targetCameraPos, 0.05);
                controls.target.lerp(targetControlsTarget, 0.05);
            }

            // ğŸŒ¸ ê½ƒ ì• ë‹ˆë©”ì´ì…˜ ì²˜ë¦¬
            flowers.forEach(flower => {
                // 1. ì„±ì¥ ì• ë‹ˆë©”ì´ì…˜
                if (flower.userData.isGrowing) {
                    flower.userData.growProgress += 0.015;
                    let s = flower.userData.growProgress;
                    // íƒ„ì„± íš¨ê³¼ (Ease Out Back ëŠë‚Œ)
                    let scale = s;
                    if (s > 1) { s = 1; flower.userData.isGrowing = false; scale = 1; }

                    flower.userData.visual.scale.set(
                        scale * FLOWER_GLOBAL_SCALE,
                        scale * FLOWER_GLOBAL_SCALE,
                        scale * FLOWER_GLOBAL_SCALE
                    );
                }

                // 2. í”ë“¤ë¦¼ íš¨ê³¼
                flower.rotation.z = Math.sin(time * 1.5 + flower.userData.swayOffset) * 0.05;

                // âœ¨ 3. ê±°ë¦¬ì— ë”°ë¥¸ ì´ë¦„í‘œ íˆ¬ëª…ë„ ì¡°ì ˆ
                if (flower.userData.labelObject) {
                    // ì¹´ë©”ë¼ì™€ ê½ƒ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
                    const distance = camera.position.distanceTo(flower.position);

                    // ê±°ë¦¬ ë²”ìœ„ ì„¤ì • (30ë¯¸í„° ì´ë‚´ ì„ ëª…, 100ë¯¸í„° ì´ìƒ íˆ¬ëª…)
                    const minDist = 30;
                    const maxDist = 100;

                    // ê±°ë¦¬ ë¹„ìœ¨ ê³„ì‚° (0 ~ 1 ì‚¬ì´ ê°’)
                    let opacity = 1 - (distance - minDist) / (maxDist - minDist);

                    // ê°’ ì œí•œ (0 ~ 1 ì‚¬ì´ë¡œ ê³ ì •)
                    opacity = Math.max(0, Math.min(1, opacity));

                    // ë¼ë²¨ì˜ íˆ¬ëª…ë„ì— ì ìš©
                    flower.userData.labelObject.element.style.opacity = opacity;
                }
            });

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ì´ˆê¸°í™” ì‹¤í–‰
        createTerrain();
        createGrass();
        createTrees();
        createRocks();
        createCliffs();
        loadInitialFlowers();

        // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
        animate();

        // ğŸ“± ëª¨ë°”ì¼ ëœë¤ ë²„íŠ¼ ì´ë²¤íŠ¸ ì—°ê²°
        const randomBtn = document.getElementById('mobile-random-btn');

        if (randomBtn) {
            randomBtn.addEventListener('click', () => {
                // 1. ê½ƒì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ ì¤‘ë‹¨
                if (flowers.length === 0) {
                    alert("ì•„ì§ ì‹¬ì–´ì§„ ê½ƒì´ ì—†ì–´ìš”! ğŸŒ¸");
                    return;
                }

                // 2. ëœë¤í•œ ê½ƒ í•˜ë‚˜ ì„ íƒ
                const randomIndex = Math.floor(Math.random() * flowers.length);
                const randomFlower = flowers[randomIndex];

                // 3. í•´ë‹¹ ê½ƒìœ¼ë¡œ ì´ë™
                focusOnFlower(randomFlower);

                // 4. ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½ íš¨ê³¼
                const originalText = randomBtn.innerHTML;
                const ownerName = randomFlower.userData.userName || 'ëˆ„êµ°ê°€';

                randomBtn.innerHTML = `âœ¨ ${ownerName}ë‹˜ì˜ ê½ƒ!`;

                setTimeout(() => {
                    randomBtn.innerHTML = originalText;
                }, 1500);
            });
        }
    </script>
</body>

</html>