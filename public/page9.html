<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sejong Bloom - ë¬¼ ì£¼ê¸°</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="styleflowergrow.css">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>

<body>

    <div class="container">
        <div class="bg_container">
            <img src="/assets/phone11.jpg" alt="background">
        </div>

        <div id="watering-canvas-container"></div>

        <button id="finish-btn" class="next-btn hidden" onclick="window.sendAndMove()">
            ë‹¤ ìëë‹¤!!!
        </button>
    </div>

    <script>
        /* ============================================================
           1. ì„œë²„ ì „ì†¡ ë° í˜ì´ì§€ ì´ë™ ë¡œì§
        ============================================================ */
        window.sendAndMove = function () {
            const btn = document.getElementById('finish-btn');
            if (btn) {
                btn.disabled = true;
                btn.innerText = "ì „ì†¡ ì¤‘...";
            }

            const storedData = localStorage.getItem('flowerData');
            if (!storedData) {
                alert("ì €ì¥ëœ ê½ƒ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                window.location.href = 'index.html';
                return;
            }

            try {
                const data = JSON.parse(storedData);
                // ğŸ”´ ì„œë²„ IP ì£¼ì†Œë¥¼ ë³¸ì¸ì˜ AWS ì„œë²„ IPë¡œ í™•ì¸í•˜ì„¸ìš”!
                const socket = io("http://15.134.86.182:3000", {
                    transports: ['websocket'],
                    reconnectionAttempts: 1,
                    timeout: 2000
                });

                socket.on('connect', () => {
                    socket.emit("submit_flower", data);
                    setTimeout(() => {
                        alert("ì„¸ì¢…ì‹œ ì •ì›ì— ê½ƒì„ ì‹¬ì—ˆìŠµë‹ˆë‹¤!");
                        window.location.href = 'page10.html';
                    }, 500);
                });

                socket.on('connect_error', () => { window.location.href = 'page10.html'; });
                setTimeout(() => { window.location.href = 'page10.html'; }, 2500);

            } catch (e) {
                window.location.href = 'page10.html';
            }
        };
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        // --- ì „ì—­ ìƒíƒœ ë³€ìˆ˜ ---
        let isFinished = false;

        const container = document.querySelector('.container');
        let width = container.clientWidth;
        let height = container.clientHeight;

        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('watering-canvas-container').appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.set(0, 1, 10);

        // --- ğŸ’¡ ì¡°ëª… ì„¤ì • (ë°ê²Œ ìˆ˜ì •) ---
        scene.add(new THREE.AmbientLight(0xffffff, 2.0)); // ì „ì²´ ë°ê¸° ìƒí–¥
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
        dirLight.position.set(5, 10, 10);
        scene.add(dirLight);

        // --- 1. ë‚´ ê½ƒ ì´ë¯¸ì§€ ë¡œë“œ ---
        const savedDataString = localStorage.getItem('flowerData');
        let flowerTexture = null;
        if (savedDataString) {
            try {
                const flowerData = JSON.parse(savedDataString);
                if (flowerData.previewImage) flowerTexture = new THREE.TextureLoader().load(flowerData.previewImage);
            } catch (e) { }
        }

        const flower = new THREE.Mesh(
            new THREE.PlaneGeometry(6, 6),
            flowerTexture ? new THREE.MeshBasicMaterial({ map: flowerTexture, transparent: true, side: THREE.DoubleSide }) : new THREE.MeshStandardMaterial({ color: 0xff6b6b })
        );
        flower.position.set(0, -3, 0);
        const INITIAL_SCALE = 0.1;
        flower.scale.set(INITIAL_SCALE, INITIAL_SCALE, INITIAL_SCALE);
        scene.add(flower);

        // --- 2. ë¬¼ë¿Œë¦¬ê°œ ë¡œë“œ ë° ì¬ì§ˆ ìˆ˜ì • ---
        let canGroup = new THREE.Group();
        scene.add(canGroup);
        const spoutHelper = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ visible: false }));
        spoutHelper.position.set(1.8, 0.5, 0);
        canGroup.add(spoutHelper);

        const loader = new GLTFLoader();
        let isModelReady = false;
        let isUserDragging = false;

        loader.load('./assets/Watering_Can.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(0.05, 0.05, 0.05);

            // ğŸ’¡ ëª¨ë¸ì´ ê²€ê²Œ ë‚˜ì˜¤ì§€ ì•Šë„ë¡ ì¬ì§ˆ ê°•ì œ ë¶€ì—¬
            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({
                        color: 0xFFD700,      // ë°ì€ ë…¸ë€ìƒ‰/ê¸ˆìƒ‰
                        metalness: 0.4,
                        roughness: 0.3,
                        emissive: 0x111100   // ì–´ë‘ìš´ ê³³ì—ì„œë„ ì‚´ì§ ìƒ‰ì´ ë³´ì´ê²Œ í•¨
                    });
                }
            });

            canGroup.add(model);
            canGroup.position.set(0, 3.5, 0);
            
            const controls = new DragControls([canGroup], camera, renderer.domElement);
            controls.transformGroup = true;
            controls.addEventListener('dragstart', () => { isUserDragging = true; });
            controls.addEventListener('dragend', () => { isUserDragging = false; });
            isModelReady = true;
        });

        // --- 3. íŒŒí‹°í´ (ë¬¼ë°©ìš¸) ---
        const particleCount = 400;
        const geom = new THREE.BufferGeometry();
        const pos = new Float32Array(particleCount * 3);
        const vel = new Float32Array(particleCount);
        for (let i = 0; i < particleCount; i++) { pos[i * 3 + 1] = -500; vel[i] = -0.15 - Math.random() * 0.15; }
        geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const pSystem = new THREE.Points(geom, new THREE.PointsMaterial({ color: 0x4fa3ff, size: 0.12, transparent: true, opacity: 0.7 }));
        scene.add(pSystem);

        // --- 4. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ---
        let wateringFrames = 0;
        const REQUIRED_FRAMES = 180;

        function animate() {
            if (isFinished) return;
            requestAnimationFrame(animate);
            if (!canGroup || !isModelReady) return;

            const dist = canGroup.position.distanceTo(flower.position);
            const isNear = dist < 5.5;

            let targetRotZ = (isUserDragging && isNear) ? -Math.PI / 4 : 0;
            canGroup.rotation.z = THREE.MathUtils.lerp(canGroup.rotation.z, targetRotZ, 0.1);
            
            const isActuallyWatering = canGroup.rotation.z < -0.25;
            pSystem.visible = isActuallyWatering;

            if (isActuallyWatering) {
                wateringFrames++;
                const progress = Math.min(wateringFrames / REQUIRED_FRAMES, 1.0);
                const currentScale = INITIAL_SCALE + (1.0 - INITIAL_SCALE) * progress;
                flower.scale.set(currentScale, currentScale, currentScale);

                const arr = geom.attributes.position.array;
                const spoutPos = new THREE.Vector3();
                spoutHelper.getWorldPosition(spoutPos);
                for (let i = 0; i < particleCount; i++) {
                    if (arr[i * 3 + 1] < -3) {
                        arr[i * 3] = spoutPos.x + (Math.random()-0.5)*0.2;
                        arr[i * 3 + 1] = spoutPos.y;
                        arr[i * 3 + 2] = spoutPos.z;
                    }
                    arr[i * 3 + 1] += vel[i];
                }
                geom.attributes.position.needsUpdate = true;

                if (wateringFrames >= REQUIRED_FRAMES) {
                    finishWatering();
                }
            }
            renderer.render(scene, camera);
        }

        function finishWatering() {
            if (isFinished) return;
            isFinished = true;
            scene.remove(canGroup);
            scene.remove(pSystem);
            flower.scale.set(1, 1, 1);
            renderer.render(scene, camera);

            const btn = document.getElementById('finish-btn');
            if (btn) {
                btn.classList.remove('hidden');
                btn.classList.add('visible');
            }
        }

        animate();
        window.addEventListener('resize', () => {
            renderer.setSize(container.clientWidth, container.clientHeight);
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>

</html>