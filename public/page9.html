<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sejong Bloom - The Garden</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
        }

        /* 3D ÎùºÎ≤® Ïä§ÌÉÄÏùº */
        .flower-label {
            margin-top: -45px;
            color: white;
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8);
            padding: 5px;
            pointer-events: none;
            opacity: 0.9;
        }

        #guide {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 18px;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            max-height: 80vh;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            border-radius: 15px;
            padding: 15px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            color: white;
            font-family: 'Noto Sans KR', sans-serif;
            z-index: 20;
        }

        #ui-container h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.4);
            padding-bottom: 5px;
        }

        .flower-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
        }

        .flower-item:hover {
            background: rgba(255, 255, 255, 0.3);
            color: #333;
        }

        .flower-icon {
            margin-right: 8px;
        }

        #ui-container::-webkit-scrollbar {
            width: 6px;
        }

        #ui-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 3px;
        }

        /* ÎÇ¥ ÍΩÉ Ï∞æÍ∏∞ Î≤ÑÌäº Ï∂îÍ∞Ä */
        #find-my-flower-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            padding: 10px 20px;
            background: white;
            border: none;
            border-radius: 20px;
            font-family: 'Noto Sans KR', sans-serif;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-weight: bold;
        }
    </style>

    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body>
    <button id="find-my-flower-btn">üè° ÎÇ¥ ÍΩÉ Î≥¥Îü¨Í∞ÄÍ∏∞</button>

    <div id="guide">ÍΩÉÏùÑ ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò Î¶¨Ïä§Ìä∏Î•º ÎàåÎü¨Î≥¥ÏÑ∏Ïöî! üå∏</div>
    <div id="ui-container">
        <h3>üå± Ï†ïÏõê Î∞©Î™ÖÎ°ù</h3>
        <div id="flower-list"></div>
    </div>

    <script type="x-shader/x-vertex" id="skyVertexShader">
        varying vec2 vUv; varying vec3 vWorldPosition; void main() { vUv = uv; vec4 worldPosition = modelMatrix * vec4(position, 1.0); vWorldPosition = worldPosition.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>
    <script type="x-shader/x-fragment" id="skyFragmentShader">
        uniform vec3 uColorSkyTop; uniform vec3 uColorSkyBottom; uniform vec3 uColorCloud; uniform float uTime; varying vec2 vUv; varying vec3 vWorldPosition;
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); } vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0)); float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ * ns.x + ns.yyyy; vec4 y = y_ * ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw); vec4 s0 = floor(b0) * 2.0 + 1.0; vec4 s1 = floor(b1) * 2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw * sh.xzyw; vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww; vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); m = m * m; return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))); }
        void main() { float horizon = normalize(vWorldPosition).y; vec3 skyColor = mix(uColorSkyBottom, uColorSkyTop, max(horizon, 0.0)); float cloudNoise = snoise(vWorldPosition * 0.0008 + vec3(uTime * 0.015, 0.0, uTime * 0.005)); cloudNoise += snoise(vWorldPosition * 0.002 + vec3(uTime * 0.03)) * 0.4; float cloudIntensity = smoothstep(0.45, 0.75, cloudNoise); cloudIntensity *= smoothstep(0.0, 0.15, horizon); vec3 finalColor = mix(skyColor, uColorCloud, cloudIntensity); gl_FragColor = vec4(finalColor, 1.0); }
    </script>
    <script type="x-shader/x-vertex" id="grassVertexShader">
        varying vec2 vUv; varying float vHeight; uniform float uTime; void main() { vUv = uv; vec4 worldPosition = instanceMatrix * vec4(position, 1.0); vHeight = position.y; float wind = sin(uTime * 0.8 + worldPosition.x * 0.2 + worldPosition.z * 0.2) * 0.08; wind += cos(uTime * 2.0 + worldPosition.x * 0.1) * 0.04; float bend = smoothstep(0.0, 1.0, vHeight); vec3 pos = position; pos.x += wind * bend * 2.0; pos.z += wind * bend * 1.0; gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(pos, 1.0); }
    </script>
    <script type="x-shader/x-fragment" id="grassFragmentShader">
        varying float vHeight; uniform vec3 uColorBottom; uniform vec3 uColorTop; void main() { float smoothHeight = pow(vHeight, 0.7); vec3 baseColor = mix(uColorBottom, uColorTop, smoothHeight); float softGlow = smoothstep(0.5, 1.0, vHeight) * 0.2; vec3 finalColor = baseColor + softGlow + vec3(0.05); gl_FragColor = vec4(finalColor, 1.0); }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // üü¢ localStorageÎ°ú ÏàòÏ†ï (ÏòÅÍµ¨ Ïù¥Î¶Ñ Í∏∞Ïñµ)
        const myName = localStorage.getItem('userName');
        const SERVER_URL = "http://15.134.86.182:3000";

        const CONFIG = {
            flowerScale: 1.5,
            worldSize: 250, grassCount: 150000, treeCount: 50, rockCount: 60
        };

        let seedValue = 123456;
        function seededRandom() {
            var t = seedValue += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        const loader = new GLTFLoader();
        const prefabCache = {};
        const flowers = [];
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 30, 90);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.maxDistance = 150; controls.minDistance = 5;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.target.set(0, 5, 0); controls.enableDamping = true;

        const sunLight = new THREE.DirectionalLight(0xfff0dd, 2.0);
        sunLight.position.set(80, 100, 60);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(2048, 2048);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0xcceeff, 0.7));

        // ÌôòÍ≤Ω ÏÉùÏÑ± Ìï®ÏàòÎì§ ÎèôÏùº (Terrain, Sky, Grass, Trees, Rocks, Cliffs)
        const skyUniforms = { uTime: { value: 0 }, uColorSkyTop: { value: new THREE.Color(0x4CA1D3) }, uColorSkyBottom: { value: new THREE.Color(0xAEEEEE) }, uColorCloud: { value: new THREE.Color(0xFFFFFF) } };
        const skyMat = new THREE.ShaderMaterial({ vertexShader: document.getElementById('skyVertexShader').textContent, fragmentShader: document.getElementById('skyFragmentShader').textContent, uniforms: skyUniforms, side: THREE.BackSide });
        scene.add(new THREE.Mesh(new THREE.SphereGeometry(4000, 32, 32), skyMat));
        scene.fog = new THREE.Fog(0xAEEEEE, 60, 200);

        function getTerrainHeight(x, z) { const y1 = Math.sin(x * 0.02) * 6.0; const y2 = Math.cos(z * 0.025) * 5.0; const y3 = Math.sin(x * 0.05 + z * 0.05) * 2.0; return (y1 + y2 + y3) - 3; }
        function createTerrain() { const geo = new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize, 64, 64); geo.rotateX(-Math.PI / 2); const pos = geo.attributes.position; for (let i = 0; i < pos.count; i++) { pos.setY(i, getTerrainHeight(pos.getX(i), pos.getZ(i))); } geo.computeVertexNormals(); const mat = new THREE.MeshStandardMaterial({ color: 0x7a9c6b }); const terrain = new THREE.Mesh(geo, mat); terrain.receiveShadow = true; scene.add(terrain); }

        const grassUniforms = { uTime: { value: 0 }, uColorBottom: { value: new THREE.Color(0x6a9e7a) }, uColorTop: { value: new THREE.Color(0xc3e8a8) } };
        function createGrass() { const grassGeo = new THREE.ConeGeometry(0.03, 1.0, 3, 1); grassGeo.translate(0, 0.5, 0); const grassMat = new THREE.ShaderMaterial({ vertexShader: document.getElementById('grassVertexShader').textContent, fragmentShader: document.getElementById('grassFragmentShader').textContent, uniforms: grassUniforms, side: THREE.DoubleSide }); const mesh = new THREE.InstancedMesh(grassGeo, grassMat, CONFIG.grassCount); for (let i = 0; i < CONFIG.grassCount; i++) { const x = (seededRandom() - 0.5) * CONFIG.worldSize; const z = (seededRandom() - 0.5) * CONFIG.worldSize; const y = getTerrainHeight(x, z); dummy.position.set(x, y, z); const scale = 0.6 + seededRandom() * 0.6; dummy.scale.set(scale, scale * 0.8, scale); dummy.rotation.y = seededRandom() * Math.PI; dummy.rotation.x = (seededRandom() - 0.5) * 0.3; dummy.rotation.z = (seededRandom() - 0.5) * 0.3; dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); } mesh.receiveShadow = true; scene.add(mesh); }

        function createTrees() { const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 5); trunkGeo.translate(0, 0.75, 0); const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5D4037, flatShading: true }); const leafGeo = new THREE.DodecahedronGeometry(2.2, 0); leafGeo.translate(0, 3.0, 0); const leafMat = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true }); const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, CONFIG.treeCount); const leafMesh = new THREE.InstancedMesh(leafGeo, leafMat, CONFIG.treeCount); const leafColors = [0xFF7F50, 0xFFA07A, 0xFFD700, 0xE9967A]; for (let i = 0; i < CONFIG.treeCount; i++) { let x, z, dist; do { x = (seededRandom() - 0.5) * CONFIG.worldSize; z = (seededRandom() - 0.5) * CONFIG.worldSize; dist = Math.sqrt(x * x + z * z); } while (dist < 35); const y = getTerrainHeight(x, z); dummy.position.set(x, y, z); const scale = 0.8 + seededRandom() * 0.8; dummy.scale.set(scale, scale, scale); dummy.rotation.y = seededRandom() * Math.PI; dummy.updateMatrix(); trunkMesh.setMatrixAt(i, dummy.matrix); leafMesh.setMatrixAt(i, dummy.matrix); color.setHex(leafColors[Math.floor(seededRandom() * leafColors.length)]); leafMesh.setColorAt(i, color); } scene.add(trunkMesh); scene.add(leafMesh); }

        function createRocks() { const geo = new THREE.DodecahedronGeometry(1, 0); const mat = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, flatShading: true }); const mesh = new THREE.InstancedMesh(geo, mat, CONFIG.rockCount); for (let i = 0; i < CONFIG.rockCount; i++) { const x = (seededRandom() - 0.5) * CONFIG.worldSize; const z = (seededRandom() - 0.5) * CONFIG.worldSize; const y = getTerrainHeight(x, z); dummy.position.set(x, y + 0.3, z); dummy.scale.set(1 + seededRandom(), 0.6 + seededRandom(), 1 + seededRandom()); dummy.rotation.set(seededRandom() * 3, seededRandom() * 3, seededRandom() * 3); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); } scene.add(mesh); }

        function createCliffs() { const columnGeo = new THREE.CylinderGeometry(3.5, 3.5, 60, 6); columnGeo.translate(0, 30, 0); const columnMat = new THREE.MeshStandardMaterial({ color: 0x3E424B, flatShading: true, roughness: 0.9 }); const cliffClusters = 8; const columnsPerCluster = 50; const totalColumns = cliffClusters * columnsPerCluster; const cliffMesh = new THREE.InstancedMesh(columnGeo, columnMat, totalColumns); let idx = 0; for (let i = 0; i < cliffClusters; i++) { const angle = (i / cliffClusters) * Math.PI * 2 + seededRandom() * 0.5; const dist = CONFIG.worldSize / 2 + 10 + seededRandom() * 20; const centerX = Math.cos(angle) * dist; const centerZ = Math.sin(angle) * dist; for (let j = 0; j < columnsPerCluster; j++) { const offsetX = (seededRandom() - 0.5) * 35; const offsetZ = (seededRandom() - 0.5) * 35; const heightScale = 0.8 + seededRandom() * 1.4; const groundY = getTerrainHeight(centerX + offsetX, centerZ + offsetZ); dummy.position.set(centerX + offsetX, groundY - 15, centerZ + offsetZ); dummy.scale.set(1, heightScale, 1); dummy.rotation.set(0, seededRandom() * Math.PI, 0); dummy.updateMatrix(); cliffMesh.setMatrixAt(idx++, dummy.matrix); } } scene.add(cliffMesh); }

        async function getModel(prefabName) {
            if (prefabCache[prefabName]) return prefabCache[prefabName];
            const path = `./assets/${prefabName}.glb`;
            try {
                const gltf = await loader.loadAsync(path);
                prefabCache[prefabName] = gltf.scene;
                return gltf.scene;
            } catch (e) { return null; }
        }

        async function createFlower(data, isFromSocket = false) {
            try {
                const flowerHolder = new THREE.Group();
                flowerHolder.userData = { isFlower: true, isGrowing: true, growProgress: 0, swayOffset: Math.random() * 100, userName: data.userName };

                let x = Number(data.gardenX);
                let z = Number(data.gardenZ);
                if (isNaN(x) || isNaN(z)) { x = 0; z = 0; }

                let y = getTerrainHeight(x, z) + 0.5;
                flowerHolder.position.set(x, y, z);

                const parts = Array.isArray(data.unityData) ? data.unityData : [];
                const BLOOM_SCALE = 120.0;

                for (const partData of parts) {
                    const container = new THREE.Group();
                    container.position.set(partData.posX * BLOOM_SCALE, partData.posY * BLOOM_SCALE, partData.sortOrder * 0.1);
                    container.rotation.z = THREE.MathUtils.degToRad(-partData.rotation);
                    const s = partData.scaleX * BLOOM_SCALE;
                    container.scale.set(s, s, s);

                    let mesh;
                    const template = await getModel(partData.prefabName);
                    if (template) {
                        mesh = template.clone();
                    } else {
                        mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.2), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                    }

                    const colorHex = partData.color.startsWith('#') ? partData.color : '#' + partData.color;
                    const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(colorHex), roughness: 0.6, metalness: 0.1, side: THREE.DoubleSide });

                    mesh.traverse((c) => { if (c.isMesh) { c.material = mat; c.castShadow = true; c.receiveShadow = true; } });
                    mesh.rotation.x = -Math.PI / 2;
                    container.add(mesh);
                    flowerHolder.add(container);
                }

                const nameDiv = document.createElement('div');
                nameDiv.className = 'flower-label';
                const dispName = data.userName || 'ÏÜêÎãò';
                nameDiv.textContent = `${dispName}Ïùò ÍΩÉ`;
                const label = new CSS2DObject(nameDiv);
                label.position.set(0, 15.0, 0);
                flowerHolder.add(label);

                flowerHolder.scale.set(0, 0, 0);
                scene.add(flowerHolder);
                flowers.push(flowerHolder);

                addFlowerToList(dispName, flowerHolder);

                // üî¥ ÏÜåÏºìÏúºÎ°ú Î∞©Í∏à ÏÉùÏÑ±ÎêòÏóàÍ±∞ÎÇò ÏÉàÎ°úÍ≥†Ïπ® Ïãú ÎÇ¥ ÍΩÉÏù∏ Í≤ΩÏö∞ ÏûêÎèô Ìè¨Ïª§Ïä§
                if (isFromSocket || (myName && data.userName === myName)) {
                    focusAndExplore(flowerHolder);
                }

                return flowerHolder; // Í∞ùÏ≤¥ Î∞òÌôò Ï∂îÍ∞Ä
            } catch (err) { console.error("ÏÉùÏÑ± ÏóêÎü¨:", err); }
        }

        let isCameraLocked = false;
        let lockTimer = null;
        let targetCameraPos = new THREE.Vector3();
        let targetControlsTarget = new THREE.Vector3();

        function focusAndExplore(flowerGroup) {
            isCameraLocked = true;
            const fPos = flowerGroup.position.clone();

            targetControlsTarget.copy(fPos).add(new THREE.Vector3(0, 5, 0));
            const direction = camera.position.clone().sub(controls.target).normalize();
            targetCameraPos.copy(fPos).add(direction.multiplyScalar(20)).add(new THREE.Vector3(0, 5, 0));

            if (lockTimer) clearTimeout(lockTimer);
            lockTimer = setTimeout(() => {
                isCameraLocked = false;
                console.log("üîì ÏûêÏú† ÌÉêÏÉâ Î™®Îìú Ï†ÑÌôò!");
            }, 3500);
        }

        function focusOnFlower(flowerGroup) {
            focusAndExplore(flowerGroup);
        }

        function addFlowerToList(name, flowerGroup) {
            const listContainer = document.getElementById('flower-list');
            const item = document.createElement('div');
            item.className = 'flower-item';
            item.innerHTML = `<span class="flower-icon">üåº</span> ${name}`;
            item.onclick = () => focusOnFlower(flowerGroup);
            listContainer.prepend(item);
        }

        async function loadInitialFlowers() {
            try {
                const response = await fetch(`${SERVER_URL}/all-flowers`);
                const allFlowers = await response.json();
                
                let focused = false;
                for (const flowerData of allFlowers) {
                    const flowerObj = await createFlower(flowerData, false);
                    
                    // ÏûÖÏû• Ïãú ÎÇ¥ ÍΩÉÏù¥ ÏûàÎã§Î©¥ ÌïòÎÇòÎßå Ïπ¥Î©îÎùº Ïù¥Îèô
                    if (!focused && myName && flowerData.userName === myName) {
                        focusAndExplore(flowerObj);
                        focused = true;
                    }
                }
            } catch (e) { console.error(e); }
        }

        const socket = io(SERVER_URL);
        socket.on("to_unity", (data) => createFlower(data, true));

        // üè° ÎÇ¥ ÍΩÉ Î≥¥Îü¨Í∞ÄÍ∏∞ Î≤ÑÌäº Ïù¥Î≤§Ìä∏
        document.getElementById('find-my-flower-btn').onclick = () => {
            const myFlowerObj = flowers.find(group => group.userData.userName === myName);
            if (myFlowerObj) {
                focusOnFlower(myFlowerObj);
            } else {
                alert("Ï†ïÏõêÏóêÏÑú ÎÇ¥ ÍΩÉÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
            }
        };

        window.addEventListener('pointerdown', (event) => {
            if (event.target.closest('#ui-container') || event.target.closest('#find-my-flower-btn')) return;
            if (isCameraLocked) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(flowers, true);
            if (intersects.length > 0) {
                let targetGroup = intersects[0].object;
                while (targetGroup.parent && targetGroup.parent.type !== 'Scene') targetGroup = targetGroup.parent;
                if (targetGroup && targetGroup.userData.isFlower) { focusOnFlower(targetGroup); }
            }
        });

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            grassUniforms.uTime.value = time; 
            skyUniforms.uTime.value = time;

            if (isCameraLocked) {
                camera.position.lerp(targetCameraPos, 0.05);
                controls.target.lerp(targetControlsTarget, 0.05);
            }
            
            controls.update();

            flowers.forEach(flower => {
                if (flower.userData.isGrowing) {
                    flower.userData.growProgress += 0.015;
                    let s = Math.min(flower.userData.growProgress, 1.0);
                    if (s >= 1.0) flower.userData.isGrowing = false;
                    flower.scale.set(s, s, s);
                }
                flower.rotation.z = Math.sin(time * 1.5 + flower.userData.swayOffset) * 0.05;
            });

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        createTerrain(); createGrass(); createTrees(); createRocks(); createCliffs();
        loadInitialFlowers();
        animate();
    </script>
</body>

</html>