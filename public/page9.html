<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sejong Bloom - ë¬¼ ì£¼ê¸°</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="styleflowergrow.css">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>

<body>

    <div class="container">
        <div class="bg_container">
            <picture>
                <!-- ì•„ì´íŒ¨ë“œ ì„¸ë¡œ -->
                <source srcset="/assets/IPAD10.jpg" media="(min-width: 768px) and (orientation: portrait)"
                    class="bg-image">
                <!-- ê¸°ë³¸ (ëª¨ë°”ì¼ + ì•„ì´íŒ¨ë“œ ê°€ë¡œ + ë°ìŠ¤í¬íƒ‘) -->
                <img src="/assets/phone11.jpg" alt="Sejong Bloom" class="main-img bg-image">
            </picture>
        </div>

        <div id="watering-canvas-container"></div>

        <button id="finish-btn" class="next-btn hidden" onclick="window.sendAndMove()">
            ë‹¤ ìëë‹¤!!!
        </button>
    </div>

    <script>
        /* ============================================================
           1. ì„œë²„ ì „ì†¡ ë° í˜ì´ì§€ ì´ë™ ë¡œì§
        ============================================================ */
        window.sendAndMove = async function () {
            const btn = document.getElementById('finish-btn');
            if (btn) {
                btn.disabled = true;
                btn.innerText = "í”„ë¦°íŠ¸ ì¤€ë¹„ ì¤‘...";
            }

            const storedData = localStorage.getItem('flowerData');
            if (!storedData) return;
            const data = JSON.parse(storedData);

            try {
                const transformToBlackAndWhite = async (base64Str) => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.crossOrigin = "Anonymous"; // CORS ì´ìŠˆ ë°©ì§€
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // 1. ë¨¼ì € ê½ƒì˜ ì‹¤ë£¨ì—£ì„ ê²€ì •ìƒ‰ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤.
                            // (ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ê·¸ë¦¬ê³ , ê·¸ ìœ„ì— ê²€ì •ìƒ‰ì„ ì…í˜)
                            ctx.drawImage(img, 0, 0);
                            ctx.globalCompositeOperation = 'source-in';
                            ctx.fillStyle = '#000000'; // ê½ƒ ì˜ì—­ì„ ê²€ì •ìœ¼ë¡œ
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // 2. ì¤‘ìš”: 'destination-over'ë¥¼ ì‚¬ìš©í•˜ì—¬ ê½ƒ(ê²€ì •) "ë’¤ì—" í°ìƒ‰ ë°°ê²½ì„ ê¹ë‹ˆë‹¤.
                            ctx.globalCompositeOperation = 'destination-over';
                            ctx.fillStyle = '#ffffff'; // ë°°ê²½ì„ í°ìƒ‰ìœ¼ë¡œ
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // 3. ì„¤ì •ì„ ì´ˆê¸°í™”í•˜ê³  ê²°ê³¼ ë°˜í™˜
                            ctx.globalCompositeOperation = 'source-over';
                            resolve(canvas.toDataURL('image/png'));
                        };
                        img.src = base64Str;
                    });
                };

                // í‘ë°± ì´ë¯¸ì§€ ìƒì„±
                const blackWhiteImage = await transformToBlackAndWhite(data.previewImage);

                // ì„œë²„ì— ë®ì–´ì“°ê¸° ìš”ì²­
                await fetch('http://15.134.86.182:3000/upload-flower', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        location: data.location,
                        image: blackWhiteImage,
                        userName: data.userName
                    })
                });

                // ì†Œì¼“ ì‹ í˜¸ ì „ì†¡
                const socket = io("http://15.134.86.182:3000", {
                    transports: ['websocket'],
                    reconnectionAttempts: 1
                });

                socket.on('connect', () => {
                    socket.emit("submit_flower", data);
                    setTimeout(() => {
                        alert("ì •ì›ì— ê½ƒì„ ì‹¬ì—ˆìŠµë‹ˆë‹¤! ì˜ìˆ˜ì¦ì„ í™•ì¸í•˜ì„¸ìš”.");
                        window.location.href = 'page10.html';
                    }, 500);
                });

            } catch (e) {
                console.error("ìµœì¢… ì²˜ë¦¬ ì¤‘ ì—ëŸ¬:", e);
                window.location.href = 'page10.html';
            }
        };
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        // --- ì „ì—­ ìƒíƒœ ë³€ìˆ˜ ---
        let isFinished = false;

        const container = document.querySelector('.container');
        let width = container.clientWidth;
        let height = container.clientHeight;

        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('watering-canvas-container').appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.set(0, 1, 10);

        // --- ğŸ’¡ ì¡°ëª… ì„¤ì • (ë°ê²Œ ìˆ˜ì •) ---
        scene.add(new THREE.AmbientLight(0xffffff, 2.0)); // ì „ì²´ ë°ê¸° ìƒí–¥
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
        dirLight.position.set(5, 10, 10);
        scene.add(dirLight);

        // --- 1. ë‚´ ê½ƒ ì´ë¯¸ì§€ ë¡œë“œ ---
        const savedDataString = localStorage.getItem('flowerData');
        let flowerTexture = null;
        if (savedDataString) {
            try {
                const flowerData = JSON.parse(savedDataString);
                if (flowerData.previewImage) flowerTexture = new THREE.TextureLoader().load(flowerData.previewImage);
            } catch (e) { }
        }

        const flower = new THREE.Mesh(
            new THREE.PlaneGeometry(6, 6),
            flowerTexture ? new THREE.MeshBasicMaterial({ map: flowerTexture, transparent: true, side: THREE.DoubleSide }) : new THREE.MeshStandardMaterial({ color: 0xff6b6b })
        );
        flower.position.set(0, -3, 0);
        const INITIAL_SCALE = 0.1;
        flower.scale.set(INITIAL_SCALE, INITIAL_SCALE, INITIAL_SCALE);
        scene.add(flower);

        // --- 2. ë¬¼ë¿Œë¦¬ê°œ ë¡œë“œ ë° ì¬ì§ˆ ìˆ˜ì • ---
        let canGroup = new THREE.Group();
        scene.add(canGroup);
        const spoutHelper = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ visible: false }));
        spoutHelper.position.set(1.8, 0.2, 0);
        canGroup.add(spoutHelper);

        const loader = new GLTFLoader();
        let isModelReady = false;
        let isUserDragging = false;

        loader.load('./assets/Watering_Can.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(0.05, 0.05, 0.05);

            // ğŸ’¡ ëª¨ë¸ì´ ê²€ê²Œ ë‚˜ì˜¤ì§€ ì•Šë„ë¡ ì¬ì§ˆ ê°•ì œ ë¶€ì—¬
            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({
                        color: 0xFFD700,      // ë°ì€ ë…¸ë€ìƒ‰/ê¸ˆìƒ‰
                        metalness: 0.4,
                        roughness: 0.3,
                        emissive: 0x111100   // ì–´ë‘ìš´ ê³³ì—ì„œë„ ì‚´ì§ ìƒ‰ì´ ë³´ì´ê²Œ í•¨
                    });
                }
            });

            canGroup.add(model);
            canGroup.position.set(0, 3.5, 0);

            const controls = new DragControls([canGroup], camera, renderer.domElement);
            controls.transformGroup = true;
            controls.addEventListener('dragstart', () => { isUserDragging = true; });
            controls.addEventListener('dragend', () => { isUserDragging = false; });
            isModelReady = true;
        });

        // --- 3. íŒŒí‹°í´ (ë¬¼ë°©ìš¸) ---
        const particleCount = 400;
        const geom = new THREE.BufferGeometry();
        const pos = new Float32Array(particleCount * 3);
        const vel = new Float32Array(particleCount);
        for (let i = 0; i < particleCount; i++) { pos[i * 3 + 1] = -500; vel[i] = -0.15 - Math.random() * 0.15; }
        geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const pSystem = new THREE.Points(geom, new THREE.PointsMaterial({ color: 0x4fa3ff, size: 0.12, transparent: true, opacity: 0.7 }));
        scene.add(pSystem);

        // --- 4. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ---
        let wateringFrames = 0;
        const REQUIRED_FRAMES = 180;

        function animate() {
            if (isFinished) return;
            requestAnimationFrame(animate);
            if (!canGroup || !isModelReady) return;

            const dist = canGroup.position.distanceTo(flower.position);
            const isNear = dist < 5.5;

            let targetRotZ = (isUserDragging && isNear) ? -Math.PI / 4 : 0;
            canGroup.rotation.z = THREE.MathUtils.lerp(canGroup.rotation.z, targetRotZ, 0.1);

            const isActuallyWatering = canGroup.rotation.z < -0.25;
            pSystem.visible = isActuallyWatering;

            if (isActuallyWatering) {
                wateringFrames++;
                const progress = Math.min(wateringFrames / REQUIRED_FRAMES, 1.0);
                const currentScale = INITIAL_SCALE + (1.0 - INITIAL_SCALE) * progress;
                flower.scale.set(currentScale, currentScale, currentScale);

                const arr = geom.attributes.position.array;
                const spoutPos = new THREE.Vector3();
                spoutHelper.getWorldPosition(spoutPos);
                for (let i = 0; i < particleCount; i++) {
                    if (arr[i * 3 + 1] < -3) {
                        arr[i * 3] = spoutPos.x + (Math.random() - 0.5) * 0.2;
                        arr[i * 3 + 1] = spoutPos.y;
                        arr[i * 3 + 2] = spoutPos.z;
                    }
                    arr[i * 3 + 1] += vel[i];
                }
                geom.attributes.position.needsUpdate = true;

                if (wateringFrames >= REQUIRED_FRAMES) {
                    finishWatering();
                }
            }
            renderer.render(scene, camera);
        }

        function finishWatering() {
            if (isFinished) return;
            isFinished = true;
            scene.remove(canGroup);
            scene.remove(pSystem);
            flower.scale.set(1, 1, 1);
            renderer.render(scene, camera);

            const btn = document.getElementById('finish-btn');
            if (btn) {
                btn.classList.remove('hidden');
                btn.classList.add('visible');
            }
        }

        animate();
        window.addEventListener('resize', () => {
            renderer.setSize(container.clientWidth, container.clientHeight);
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>

</html>