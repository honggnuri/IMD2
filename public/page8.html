<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sejong Bloom - ë¬¼ ì£¼ê¸°</title>

    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="styleflowergrow.css">

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>

<body>

    <div class="container">
        <div class="bg_container">
            <img src="/assets/phone11.jpg" alt="background">
        </div>

        <div id="watering-canvas-container"></div>

        <button id="finish-btn" class="next-btn hidden" onclick="window.sendAndMove()">
            ë‹¤ ìëë‹¤!!!
        </button>
    </div>

    <script>
        // ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡í•˜ì—¬ HTML ë²„íŠ¼ì´ ë¬´ì¡°ê±´ ì°¾ì„ ìˆ˜ ìˆê²Œ í•¨
        window.sendAndMove = function() {
            console.log("ğŸ‘† ë²„íŠ¼ í´ë¦­ë¨! ë¡œì§ ì‹œì‘");

            const btn = document.getElementById('finish-btn');
            if (btn) {
                btn.disabled = true;
                btn.innerText = "ì „ì†¡ ì¤‘...";
            }

            // 1. ë°ì´í„° í™•ì¸
            const storedData = sessionStorage.getItem('flowerData');
            if (!storedData) {
                alert("ì €ì¥ëœ ê½ƒ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ìŒìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.");
                window.location.href = 'page9.html';
                return;
            }

            // 2. ì†Œì¼“ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì²´í¬
            if (typeof io === 'undefined') {
                console.error("Socket.io ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì‹¤íŒ¨");
                alert("ì„œë²„ ì—°ê²° ë¶ˆê°€. ë‹¤ìŒìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.");
                window.location.href = 'page9.html';
                return;
            }

            // 3. ì „ì†¡ ì‹œë„
            try {
                const data = JSON.parse(storedData);
                console.log("ğŸ“¦ ì „ì†¡í•  ë°ì´í„°:", data);

                // ì„œë²„ ì£¼ì†Œ (http ì£¼ì˜)
                const socket = io("http://15.134.86.182:3000", {
                    transports: ['websocket'],
                    reconnectionAttempts: 1, // ì¬ì—°ê²° 1íšŒë§Œ ì‹œë„
                    timeout: 2000            // 2ì´ˆ íƒ€ì„ì•„ì›ƒ
                });

                // A. ì—°ê²° ì„±ê³µ ì‹œ
                socket.on('connect', () => {
                    console.log("âœ… ì„œë²„ ì—°ê²° ì„±ê³µ!");
                    socket.emit("submit_flower", data);
                    
                    // ì „ì†¡ í›„ ì ì‹œ ë’¤ ì´ë™
                    setTimeout(() => {
                        alert("ì„¸ì¢…ì‹œ ì •ì›ì— ê½ƒì„ ì‹¬ì—ˆìŠµë‹ˆë‹¤!");
                        window.location.href = 'page9.html';
                    }, 500);
                });

                // B. ì—°ê²° ì—ëŸ¬ ì‹œ (ì„œë²„ êº¼ì§, ì£¼ì†Œ ë‹¤ë¦„ ë“±)
                socket.on('connect_error', (err) => {
                    console.warn("âš ï¸ ì„œë²„ ì—°ê²° ì—ëŸ¬ (ë¬´ì‹œí•˜ê³  ì´ë™):", err);
                    window.location.href = 'page9.html';
                });

                // C. íƒ€ì„ì•„ì›ƒ ê°•ì œ ì´ë™ (ë§Œì•½ ìœ„ ì´ë²¤íŠ¸ë“¤ì´ ì•ˆ í„°ì§ˆ ê²½ìš°)
                setTimeout(() => {
                    console.log("â° íƒ€ì„ì•„ì›ƒ: ê°•ì œ ì´ë™");
                    window.location.href = 'page9.html';
                }, 2500);

            } catch (e) {
                console.error("âŒ ë¡œì§ ì—ëŸ¬:", e);
                window.location.href = 'page9.html';
            }
        };
    </script>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        // --- 0. ì”¬ ì„¤ì • ---
        const container = document.querySelector('.container');
        let width = container.clientWidth;
        let height = container.clientHeight;

        const scene = new THREE.Scene();
        // ë°°ê²½ íˆ¬ëª… ì²˜ë¦¬
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0); 
        document.getElementById('watering-canvas-container').appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.set(0, 1, 10);

        scene.add(new THREE.AmbientLight(0xffffff, 1.2));
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);


        // --- 1. ê½ƒ ë°ì´í„° ë¡œë“œ ---
        const savedDataString = sessionStorage.getItem('flowerData');
        let flowerTexture = null;

        if (savedDataString) {
            try {
                const flowerData = JSON.parse(savedDataString);
                // Page 7 ë²„ì „ì— ë”°ë¼ í‚¤ê°’ì´ ë‹¤ë¥¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë‘˜ ë‹¤ ì²´í¬
                const imgSrc = flowerData.previewImage || flowerData.image; 
                
                if (imgSrc) {
                    flowerTexture = new THREE.TextureLoader().load(imgSrc);
                }
            } catch(e) {
                console.warn("ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨, ê¸°ë³¸ ê½ƒ ì‚¬ìš©");
            }
        }

        let flower;
        if (flowerTexture) {
            // ì‚¬ìš©ì ê½ƒ ì´ë¯¸ì§€ (Plane)
            flower = new THREE.Mesh(
                new THREE.PlaneGeometry(6, 6),
                new THREE.MeshBasicMaterial({ map: flowerTexture, transparent: true, side: THREE.DoubleSide })
            );
        } else {
            // ê¸°ë³¸ êµ¬ì²´ (í…ŒìŠ¤íŠ¸ìš©)
            flower = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.MeshStandardMaterial({ color: 0xff6b6b })
            );
        }
        
        flower.position.set(0, -3, 0); 
        const INITIAL_SCALE = 0.1;
        flower.scale.set(INITIAL_SCALE, INITIAL_SCALE, INITIAL_SCALE);
        scene.add(flower);


        // --- 2. ë¬¼ë¿Œë¦¬ê°œ ë¡œë“œ ---
        let canGroup = new THREE.Group();
        scene.add(canGroup);

        const spoutHelper = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 8, 8),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        spoutHelper.position.set(1.8, 0.5, 0);
        canGroup.add(spoutHelper);

        const loader = new GLTFLoader();
        let isModelReady = false; 
        let isUserDragging = false; 

        function getResponsiveParams() {
            const isMobile = window.innerWidth < 768; 
            if (isMobile) {
                return { scale: 1.2, posX: 0, posY: 0.8 }; 
            } else {
                return { scale: 1.0, posX: 0, posY: 3.5 }; 
            }
        }

        loader.load('./assets/Watering_Can.glb', (gltf) => {
            const model = gltf.scene;
            model.scale.set(0.05, 0.05, 0.05);

            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({
                        color: 0xFFD700, 
                        roughness: 0.4,
                        metalness: 0.3
                    });
                }
            });

            canGroup.add(model);
            
            const params = getResponsiveParams();
            canGroup.scale.set(params.scale, params.scale, params.scale);
            canGroup.position.set(params.posX, params.posY, 0);

            const controls = new DragControls([canGroup], camera, renderer.domElement);
            controls.transformGroup = true;

            controls.addEventListener('dragstart', () => { isUserDragging = true; });
            controls.addEventListener('dragend', () => { isUserDragging = false; });

            isModelReady = true; 
        }, undefined, (error) => {
            console.error("ë¬¼ë¿Œë¦¬ê°œ ë¡œë“œ ì‹¤íŒ¨:", error);
        });


        // --- 3. íŒŒí‹°í´ ì‹œìŠ¤í…œ ---
        const particleCount = 400;
        const geom = new THREE.BufferGeometry();
        const pos = new Float32Array(particleCount * 3);
        const vel = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            pos[i * 3 + 1] = -500; 
            vel[i] = -0.1 - Math.random() * 0.2;
        }
        geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        
        const pSystem = new THREE.Points(geom, new THREE.PointsMaterial({ 
            color: 0x4fa3ff, size: 0.15, transparent: true, opacity: 0.8 
        }));
        pSystem.frustumCulled = false;
        pSystem.visible = false; 
        scene.add(pSystem);


        // --- 4. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ---
        let targetRotZ = 0; 
        let targetRotY = 0;
        let isWatering = false;
        let wateringFrames = 0; 

        const WATERING_SECONDS = 3;  
        const REQUIRED_FRAMES = WATERING_SECONDS * 60; 
        const MAX_FLOWER_SCALE = 1.0; 

        const canPos = new THREE.Vector3();
        const flowerPos = new THREE.Vector3();
        const spoutWorldPos = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);

            if (!canGroup || !isModelReady) return;

            canGroup.getWorldPosition(canPos);
            flower.getWorldPosition(flowerPos);
            spoutHelper.getWorldPosition(spoutWorldPos);

            const dist = canPos.distanceTo(flowerPos);
            const isMobile = window.innerWidth < 768;
            const activationDist = isMobile ? 3.8 : 4.5; 

            // ë¬¼ì£¼ê¸° íŒì •
            if (isUserDragging && dist < activationDist) { 
                isWatering = true; 
                targetRotZ = -Math.PI / 4; 
            } else { 
                isWatering = false; 
                targetRotZ = 0; 
            }

            if (canPos.x > flowerPos.x) targetRotY = -Math.PI; 
            else targetRotY = 0;

            canGroup.rotation.z = THREE.MathUtils.lerp(canGroup.rotation.z, targetRotZ, 0.1);
            canGroup.rotation.y = THREE.MathUtils.lerp(canGroup.rotation.y, targetRotY, 0.1);

            const isActuallyWatering = isWatering && canGroup.rotation.z < -0.3;
            pSystem.visible = isActuallyWatering; 

            if (isActuallyWatering) {
                wateringFrames++;
                const progress = Math.min(wateringFrames / REQUIRED_FRAMES, 1.0);
                const currentScale = THREE.MathUtils.lerp(INITIAL_SCALE, MAX_FLOWER_SCALE, progress);
                
                flower.scale.set(currentScale, currentScale, currentScale);
                
                if (progress < 1.0) {
                    flower.rotation.z = Math.sin(wateringFrames * 0.1) * 0.05;
                } else {
                    flower.rotation.z = 0;
                }

                if (wateringFrames >= REQUIRED_FRAMES) {
                    finishWatering();
                    return; 
                }
            }

            if (isActuallyWatering) {
                const arr = geom.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    if (arr[i * 3 + 1] < -2) {
                        arr[i * 3] = spoutWorldPos.x + (Math.random()-0.5)*0.2;
                        arr[i * 3 + 1] = spoutWorldPos.y;
                        arr[i * 3 + 2] = spoutWorldPos.z + (Math.random()-0.5)*0.2;
                    }
                    arr[i * 3 + 1] += vel[i];
                }
                geom.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }
        animate();


        // --- 5. ì™„ë£Œ ì²˜ë¦¬ UI ---
        let isFinished = false;
        function finishWatering() {
            if (isFinished) return;
            isFinished = true;

            // ë¬¼ë¿Œë¦¬ê°œ í‡´ì¥
            if (canGroup) {
                scene.remove(canGroup);
                canGroup = null;
            }
            scene.remove(pSystem);
            renderer.render(scene, camera);

            // ë²„íŠ¼ í‘œì‹œ
            const btn = document.getElementById('finish-btn');
            if (btn) {
                btn.classList.remove('hidden');
                btn.classList.add('visible');
            }
        }

        window.addEventListener('resize', () => {
            width = container.clientWidth;
            height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });
    </script>
</body>

</html>